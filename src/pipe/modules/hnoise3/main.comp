#version 460
#extension GL_GOOGLE_include_directive    : enable
#extension GL_EXT_nonuniform_qualifier    : enable

#include "shared.glsl"
#include "himalaya/common.glsl"

layout(local_size_x = DT_LOCAL_SIZE_X, local_size_y = DT_LOCAL_SIZE_Y, local_size_z = 1) in;

// layout(std140, set = 0, binding = 0) uniform global_t
// { } global;
// layout(std140, set = 0, binding = 1) uniform params_t
// { } params;

layout( // output
    set = 1, binding = 0
) uniform writeonly image2D img_out;


// Himalayas. Created by Reinder Nijhoff 2018
// @reindernijhoff
//
// https://www.shadertoy.com/view/MdGfzh
//
// This is my first attempt to render volumetric clouds in a fragment shader.
//
// Buffer A: The main look-up texture for the cloud shapes. 
// Buffer B: A 3D (32x32x32) look-up texture with Worley Noise used to add small details 
//           to the shapes of the clouds. I have packed this 3D texture into a 2D buffer.
// 
void main()
{
  ivec2 ipos = ivec2(gl_GlobalInvocationID);
  if(any(greaterThanEqual(ipos, imageSize(img_out)))) return;

  ivec2 co = ipos;//ivec2(ipos.x, imageSize(img_out).y-ipos.y-1);
  // pack 32x32x32 3d texture in 2d texture (with padding)
  float z = floor(co.x/34.) + 8.*floor(co.y/34.);
  vec2 uv = mod(co.xy, 34.) - 1.;
  vec3 coord = vec3(uv, z) / 32.;

  float r = tilableVoronoi( coord, 16,  3. );
  float g = tilableVoronoi( coord,  4,  8. );
  float b = tilableVoronoi( coord,  4, 16. );

  float c = max(0., 1.-(r + g * .5 + b * .25) / 1.75);

  imageStore(img_out, ipos, vec4(c));
}
