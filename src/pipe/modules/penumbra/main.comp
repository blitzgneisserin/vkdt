#version 460
#extension GL_GOOGLE_include_directive    : enable
#extension GL_EXT_nonuniform_qualifier    : enable
#include "shared.glsl"
#include "common.glsl"
#include "sampling.glsl"

// Penumbra. Created by Inigo Quilez
//
// https://www.shadertoy.com/view/WdyXRD

layout(local_size_x = DT_LOCAL_SIZE_X, local_size_y = DT_LOCAL_SIZE_Y, local_size_z = 1) in;

layout(std140, set = 0, binding = 1) uniform params_t
{
  int samples;
  int texture_apply;
} params;

layout(std140, set = 0, binding = 0) uniform global_t
{
  uint frame;
} global;

layout(
    set = 1, binding = 0
) uniform writeonly image2D img_out;

float sdPlane( vec3 p )
{
	return p.y;
}

float sdBox( vec3 p, vec3 b )
{
    vec3 d = abs(p) - b;
    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
}

float sdSphere( vec3 p, float r )
{
    return length(p) - r;
}

float sdCylinder(vec3 p, float h, float r)
{
    vec2 q = vec2( length(p.xz)-r, abs(p.y-h*0.5)-h*0.5 );
    return min( max(q.x,q.y),0.0) + length(max(q,0.0));
}

bool shadowBox( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad, in float tmax ) 
{
    vec3 m = 1.0/rd;
    vec3 n = m*(ro-cen);
    vec3 k = abs(m)*rad;
    vec3 t1 = -n - k;
    vec3 t2 = -n + k;
	float tN = max( max( t1.x, t1.y ), t1.z );
	float tF = min( min( t2.x, t2.y ), t2.z );
	if( tN > tF || tF < 0.0) return false;
	return tN>0.0 && tN<tmax;
}

bool shadowSphere( in vec3 ro, in vec3 rd, in vec3 cen, in float rad, in float tmax )
{
	vec3 oc = ro - cen;
	float b = dot( oc, rd );
	float c = dot( oc, oc ) - rad*rad;
	float h = b*b - c;
	if( h<0.0 ) return false;
	float t = -b - sqrt( h );
    return t>0.0 && t<tmax;
}

bool shadowCylinder( in vec3 ro, in vec3 rd, in float he, float ra, in float tmax )
{
    float he2 = he*he;
    
    float k2 = 1.0        - rd.y*rd.y;
    float k1 = dot(ro,rd) - ro.y*rd.y;
    float k0 = dot(ro,ro) - ro.y*ro.y - ra*ra;
    
    float h = k1*k1 - k2*k0;
    if( h<0.0 ) return false;
    h = sqrt(h);
    float t = (-k1-h)/k2;

    // body
    float y = ro.y + t*rd.y;
    if( y>0.0 && y<he )
    {
        return t>0.0 && t<tmax;
    }
    
    // caps
    t = ( ((y<0.0) ? 0.0 : he) - ro.y)/rd.y;
    if( abs(k1+k2*t)<h )
    {
        return t>0.0 && t<tmax;
    }

    return false;
}

//------------------------------------------------------------------

float map( in vec3 pos )
{
    vec3 p2 = vec3( mod(pos.x+1.0,3.0)-1.0, pos.yz );
    vec3 p3 = vec3( mod(pos.x+2.0,3.0)-1.0, pos.yz );
    vec3 p4 = vec3( mod(pos.x+3.0,3.0)-1.0, pos.yz );

    float d1 = sdPlane(    pos-vec3(0.0,0.00,0.0) );
    float d2 = sdSphere(   p2-vec3(0.0,0.30,0.0), 0.4 );
    float d3 = sdBox(      p3-vec3(0.0,0.25,0.0), vec3(0.2,0.5,0.2) );
    float d4 = sdCylinder( p4-vec3(0.0,0.0,0.0), 0.8,0.3 );
      
    return min(min(d1,d2),min(d3,d4));
}

// montecarlo based shadow, for ground truth comparison
float realSoftShadow( in vec3 ro, in vec3 rd, in float tmin, in float tmax, float w, uvec2 seed )
{
    vec3 uu = normalize(cross(rd,vec3(0,1,0)));
    vec3 vv = normalize(cross(rd,uu));
    
    float tot = 0.0;
    // const int num = 32; // cast 32 rays
    // const int num = params.samples;
	// for( int j=0; j<num; j++ )
    {
        vec2 rand = next_rand(seed);
        // uniform distribution on an disk
        float ra = fsqrt(rand.x);
        float an = 6.283185*rand.y;
        vec3 jrd = rd + w*ra*(uu*cos(an)+vv*sin(an));
        
        // raycast
        float res = 1.0;
        
        for( int i=0; i<7; i++ ) // 7 objects
        {
            int k = i % 3;
            bool sha = false;
                 if(k==0) sha = shadowBox( ro, jrd, vec3(-4.0 + float(i),0.25,0.0), vec3(0.2,0.5,0.2), tmax);
            else if(k==1) sha = shadowSphere(ro, jrd, vec3(-4.0 + float(i),0.3,0.0), 0.4, tmax);
            else          sha = shadowCylinder( ro - vec3(-4.0 + float(i),0.0,0.0), jrd, 0.8, 0.3, tmax);
            
            if( sha ) { res=0.0; break; }
        }
        
        
        tot += res;
    }
    // return tot/float(num);
    return tot; // AA and samples done in the main loop
}

vec3 calcNormal( in vec3 pos )
{
    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;
    return normalize( e.xyy*map( pos + e.xyy ) + 
					  e.yyx*map( pos + e.yyx ) + 
					  e.yxy*map( pos + e.yxy ) + 
					  e.xxx*map( pos + e.xxx ) );
}

float castRay( in vec3 ro, in vec3 rd )
{
    float tmin = 1.0;
    float tmax = 20.0;
   
#if 1
    // bounding volume
    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );
    float tp2 = (1.0-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.0 ) tmin = max( tmin, tp2 );
                                                 else           tmax = min( tmax, tp2 ); }
#endif
    
    float t = tmin;
    for( int i=0; i<128; i++ )
    {
	    float precis = 0.0005*t;
	    float res = map( ro+rd*t );
        if( res<precis || t>tmax ) break;
        t += res;
    }

    if( t>tmax ) t=-1.0;
    return t;
}

float calcAO( in vec3 pos, in vec3 nor )
{
	float occ = 0.0;
    float sca = 1.0;
    for( int i=0; i<5; i++ )
    {
        float h = 0.001 + 0.15*float(i)/4.0;
        float d = map( pos + h*nor );
        occ += (h-d)*sca;
        sca *= 0.95;
    }
    return clamp( 1.0 - 1.5*occ, 0.0, 1.0 );    
}


#if 1

#define RIGID
// Standard 2x2 hash algorithm.
vec2 hash22(vec2 p) {
    
    // Faster, but probaly doesn't disperse things as nicely as other methods.
    float n = sin(dot(p, vec2(113, 1)));
    p = fract(vec2(2097152, 262144)*n)*2. - 1.;
    #ifdef RIGID
    return p;
    #else
    return cos(p*6.283 + iGlobalTime);
    //return abs(fract(p+ iGlobalTime*.25)-.5)*2. - .5; // Snooker.
    //return abs(cos(p*6.283 + iGlobalTime))*.5; // Bounce.
    #endif

}
// Standard 2D rotation formula - Nimitz says it's faster, so that's good enough for me. :)
mat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, s, -s, c); }
// Gradient noise. Ken Perlin came up with it, or a version of it. Either way, this is
// based on IQ's implementation. It's a pretty simple process: Break space into squares, 
// attach random 2D vectors to each of the square's four vertices, then smoothly 
// interpolate the space between them.
float gradN2D(in vec2 f){
    
    // Used as shorthand to write things like vec3(1, 0, 1) in the short form, e.yxy. 
   const vec2 e = vec2(0, 1);
   
    // Set up the cubic grid.
    // Integer value - unique to each cube, and used as an ID to generate random vectors for the
    // cube vertiies. Note that vertices shared among the cubes have the save random vectors attributed
    // to them.
    vec2 p = floor(f);
    f -= p; // Fractional position within the cube.
    

    // Smoothing - for smooth interpolation. Use the last line see the difference.
    //vec2 w = f*f*f*(f*(f*6.-15.)+10.); // Quintic smoothing. Slower and more squarish, but derivatives are smooth too.
    vec2 w = f*f*(3. - 2.*f); // Cubic smoothing. 
    //vec2 w = f*f*f; w = ( 7. + (w - 7. ) * f ) * w; // Super smooth, but less practical.
    //vec2 w = .5 - .5*cos(f*3.14159); // Cosinusoidal smoothing.
    //vec2 w = f; // No smoothing. Gives a blocky appearance.
    
    // Smoothly interpolating between the four verticies of the square. Due to the shared vertices between
    // grid squares, the result is blending of random values throughout the 2D space. By the way, the "dot" 
    // operation makes most sense visually, but isn't the only metric possible.
    float c = mix(mix(dot(hash22(p + e.xx), f - e.xx), dot(hash22(p + e.yx), f - e.yx), w.x),
                  mix(dot(hash22(p + e.xy), f - e.xy), dot(hash22(p + e.yy), f - e.yy), w.x), w.y);
    
    // Taking the final result, and converting it to the zero to one range.
    return c*.5 + .5; // Range: [0, 1].
}

// Gradient noise fBm.
float fBm(in vec2 p){
    
    return gradN2D(p)*.57 + gradN2D(p*2.)*.28 + gradN2D(p*4.)*.15;
    
}

// Repeat gradient lines. How you produce these depends on the effect you're after. I've used a smoothed
// triangle gradient mixed with a custom smoothed gradient to effect a little sharpness. It was produced
// by trial and error. If you're not sure what it does, just call it individually, and you'll see.
float grad(float x, float offs){
    
    // Repeat triangle wave. The tau factor and ".25" factor aren't necessary, but I wanted its frequency
    // to overlap a sine function.
    x = abs(fract(x/6.283 + offs - .25) - .5)*2.;
    
    float x2 = clamp(x*x*(-1. + 2.*x), 0., 1.); // Customed smoothed, peaky triangle wave.
    //x *= x*x*(x*(x*6. - 15.) + 10.); // Extra smooth.
    x = smoothstep(0., 1., x); // Basic smoothing - Equivalent to: x*x*(3. - 2.*x).
    return mix(x, x2, .15);
    
/*    
    // Repeat sine gradient.
    float s = sin(x + 6.283*offs + 0.);
    return s*.5 + .5;
    // Sine mixed with an absolute sine wave.
    //float sa = sin((x +  6.283*offs)/2.);
    //return mix(s*.5 + .5, 1. - abs(sa), .5);
    
*/
}

// One sand function layer... which is comprised of two mixed, rotated layers of repeat gradients lines.
float sandL(vec2 p){
    
    // Layer one. 
    vec2 q = rot2(3.14159/18.)*p; // Rotate the layer, but not too much.
    q.y += (gradN2D(q*18.) - .5)*.05; // Perturb the lines to make them look wavy.
    float grad1 = grad(q.y*80., 0.); // Repeat gradient lines.
   
    q = rot2(-3.14159/20.)*p; // Rotate the layer back the other way, but not too much.
    q.y += (gradN2D(q*12.) - .5)*.05; // Perturb the lines to make them look wavy.
    float grad2 = grad(q.y*80., .5); // Repeat gradient lines.
      
    
    // Mix the two layers above with an underlying 2D function. The function you choose is up to you,
    // but it's customary to use noise functions. However, in this case, I used a transcendental 
    // combination, because I like the way it looked better.
    // 
    // I feel that rotating the underlying mixing layers adds a little variety. Although, it's not
    // completely necessary.
    q = rot2(3.14159/4.)*p;
    //float c = mix(grad1, grad2, smoothstep(.1, .9, n2D(q*vec2(8))));//smoothstep(.2, .8, n2D(q*8.))
    //float c = mix(grad1, grad2, n2D(q*vec2(6)));//smoothstep(.2, .8, n2D(q*8.))
    //float c = mix(grad1, grad2, dot(sin(q*12. - cos(q.yx*12.)), vec2(.25)) + .5);//smoothstep(.2, .8, n2D(q*8.))
    
    // The mixes above will work, but I wanted to use a subtle screen blend of grad1 and grad2.
    float a2 = dot(sin(q*12. - cos(q.yx*12.)), vec2(.25)) + .5;
    float a1 = 1. - a2;
    
    // Screen blend.
    float c = 1. - (1. - grad1*a1)*(1. - grad2*a2);
    
    // Smooth max\min
    //float c = smax(grad1*a1, grad2*a2, .5);
   
    return c;
    
    
}

// A global value to record the distance from the camera to the hit point. It's used to tone
// down the sand height values that are further away. If you don't do this, really bad
// Moire artifacts will arise. By the way, you should always avoid globals, if you can, but
// I didn't want to pass an extra variable through a bunch of different functions.
// float gT;

float sand(vec2 p){
    
    // Rotating by 45 degrees. I thought it looked a little better this way. Not sure why.
    // I've also zoomed in by a factor of 4.
    p = vec2(p.y - p.x, p.x + p.y)*.7071/4.;
    
    // Sand layer 1.
    float c1 = sandL(p);
    
    // Second layer.
    // Rotate, then increase the frequency -- The latter is optional.
    vec2 q = rot2(3.14159/12.)*p;
    float c2 = sandL(q*1.25);
    
    // Mix the two layers with some underlying gradient noise.
    c1 = mix(c1, c2, smoothstep(.1, .9, gradN2D(p*vec2(4))));
    
/*   
	// Optional screen blending of the layers. I preferred the mix method above.
    float a2 = gradN2D(p*vec2(4));
    float a1 = 1. - a2;
    
    // Screen blend.
    c1 = 1. - (1. - c1*a1)*(1. - c2*a2);
*/    
    
    // Extra grit. Not really necessary.
    //c1 = .7 + fBm(p*128.)*.3;
    
    // A surprizingly simple and efficient hack to get rid of the super annoying Moire pattern 
    // formed in the distance. Simply lessen the value when it's further away. Most people would
    // figure this out pretty quickly, but it took me far too long before it hit me. :)
    return c1;// c1/(1. + gT*gT*.015);
}
#endif

vec3 render( in vec3 ro, in vec3 rd, float time, in float lightSize, uvec2 seed)
{ 
    vec3  col = vec3(0.0);
    float t = castRay(ro,rd);

    if( t>-0.5 )
    {
        vec3 pos = ro + t*rd;
        vec3 nor = calcNormal( pos );
        
        // material
		vec3 mate = vec3(0.3); // without texture
        if(params.texture_apply == 1)
		    mate = vec3(sand(10*pos.xz)); // with texture

        // key light
        vec3  off = vec3(0.01*time, -0.02*time, 0.01*time);
        vec3  lig = normalize( vec3(-0.2, 0.5, 0.6) + off );
        vec3  hal = normalize( lig-rd );
        
        float sha = realSoftShadow(pos, lig, 0.01, 3.0, lightSize, seed );
        float dif = clamp( dot( nor, lig ), 0.0, 1.0 ) * sha;
        
		float spe = pow(clamp(dot(nor,hal),0.0,1.0),16.0)*
                    dif *
                    (0.04+0.96*pow(clamp(1.0+dot(hal,rd),0.0,1.0),5.0));

		col = mate * 4.0*dif*vec3(1.00,0.70,0.5);
        col +=       9.0*spe*vec3(0.90,0.80,1.0);
        
        // ambient light
        float occ = (pos.y>0.01) ? 1.0 : calcAO( pos, nor );
		float amb = 0.5 + 0.5*nor.y;
        col += mate*amb*occ*vec3(0.05,0.1,0.15);
        
        // fog
        col *= exp( -0.0008*t*t*t );
    }

	return col;
}

mat3 setCamera( in vec3 ro, in vec3 ta, float cr )
{
	vec3 cw = normalize(ta-ro);
	vec3 cp = vec3(sin(cr), cos(cr),0.0);
	vec3 cu = normalize( cross(cw,cp) );
	vec3 cv = normalize( cross(cu,cw) );
    return mat3( cu, cv, cw );
}

void main()
{
  const int AA = 2;

  const ivec2 ipos = ivec2(gl_GlobalInvocationID);
  const vec2 res = imageSize(img_out);
  if(any(greaterThanEqual(ipos, res))) return;

  uvec2 seed = uvec2(
      (ipos.x + 1024*ipos.y)*1024 + global.frame, 0);

  vec3 col = vec3(0.0);
    float iTime = 0.1*global.frame;

    // camera	
    float an = 10.0 - sin(0.1*iTime);
    float shift = 0.03*iTime;
    vec3 ro = vec3( 3.0*cos(0.1*an) + shift, 1.0, -3.0*sin(0.1*an) -shift);
    vec3 ta = vec3( 0.0, -0.4, 0.0 );
    
    // camera-to-world transformation
    mat3 ca = setCamera( ro, ta, 0.0 );
    
    // animation
    int technique = 0;
    float lightSize = 0.05 + 0.04*sin(0.7);

    // render
    vec3 tot = vec3(0.0);
    const int num = params.samples;
    const float norm = 1.f/num;

    for(int s = 0; s < num; s++)
    {
        // pixel coordinates
        const vec2 fragCoord = vec2(ipos.x, res.y-ipos.y-1);
        const vec2 q = (fragCoord.xy) / res;
        const vec2 o = next_rand(seed) / res; // jitter
        vec2 p = -1.0 + 2.0 * (q + o);
        p.x *= res.x/res.y;

        // ray direction
        vec3 rd = ca * normalize( vec3(p.xy,2.0) );

        // render	
        vec3 col = render( ro, rd, iTime, lightSize, seed);

        // gain
        col = 1.8*col/(1.0+dot(col,vec3(0.333)));
        
		// gamma
        col = pow( col, vec3(0.4545) );

        // tot += col;
        tot += norm * col;

    }

    col = tot;
    imageStore(img_out, ipos, vec4(col, 1));
}
