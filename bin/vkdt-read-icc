#!/usr/bin/python3
# parse an icc profile (which you created using displaycal or so)
# and output matrix + gamma values for transformation in the fragment shader.
import os, sys
import numpy
import shutil
import subprocess
import platform

def isfloat(num):
    try:
        float(num)
        return True
    except ValueError:
        return False

if len(sys.argv) < 2:
  print('usage: vkdt read-icc your-display.icc [gamma]')
  print('requires the iccdump utility and will write display.profile files for vkdt')
  sys.exit(1)

profile=sys.argv[1]

# from PIL import ImageCms
# XXX how to get the data? the docs lie and we get a useless ImageCmsProfile
# instead of a CmsProfile object here
# prf = ImageCms.getOpenProfile(profile)
# print(prf)

# probably easier to go the bash way:
# bradford adaptation
proc = os.popen('iccdump  -v3 -t rTRC -t gTRC -t bTRC '+profile, 'r', 1)
got = proc.read().replace(',', '')
proc.close()
tokens = got.split()

if isfloat(tokens[5]):
	gamma = numpy.array([
	float(tokens[5]),
	float(tokens[11]),
	float(tokens[17])])
elif len(sys.argv) >= 3:
	gamma = numpy.array([
	float(sys.argv[2]),
	float(sys.argv[2]),
	float(sys.argv[2])])
else:
	print('this icc does not contain a simple gamma value. please specify (optional 2nd parameter)!')
	sys.exit(1)

proc = os.popen('iccdump -v3 -t wtpt -t rXYZ -t gXYZ -t bXYZ '+profile, 'r', 1)
got = proc.read().replace(',', '')
proc.close()
tokens = got.split()
wt = numpy.array([
float(tokens[6]), float(tokens[7]), float(tokens[8])])

A = numpy.matrix([
[float(tokens[19]), float(tokens[20]), float(tokens[21])],
[float(tokens[32]), float(tokens[33]), float(tokens[34])],
[float(tokens[45]), float(tokens[46]), float(tokens[47])]]).T

bradford = numpy.matrix([
[ 0.8951000,   0.2664000, -0.1614000],
[-0.7502000,   1.7135000,  0.0367000],
[ 0.0389000,  -0.0685000,  1.0296000]])

B = bradford @ A
#  D50   0.96422   1.00000   0.82521
#  D55   0.95682   1.00000   0.92149
#  D65   0.95047   1.00000   1.08883
# we need to remove the D50 white from the icc and apply ours
white = numpy.array([0.96422, 1.00000, 0.82521])
white_lms = bradford @ white
wt_lms    = bradford @ wt

C = numpy.diag(numpy.ravel(wt_lms / white_lms)) @ B
M = bradford.I @ C

# used for debugging/sanity checking
# xyz_to_srgb = numpy.matrix([ [ 3.2404542, -1.5371385, -0.4985314], [-0.9692660,  1.8760108,  0.0415560], [ 0.0556434, -0.2040259,  1.0572252] ])
# xyz_to_rec2020 = numpy.matrix([ [ 1.7166511880, -0.3556707838, -0.2533662814], [-0.6666843518,  1.6164812366,  0.0157685458], [ 0.0176398574, -0.0427706133,  0.9421031212] ])

xyz_to_dspy = M.I

xyz_to_rec2020 = numpy.matrix([
[ 1.7166511880, -0.3556707838, -0.2533662814],
[-0.6666843518,  1.6164812366,  0.0157685458],
[ 0.0176398574, -0.0427706133,  0.9421031212],
])

O = xyz_to_dspy * xyz_to_rec2020.I
print('rec2020 to display matrix')
print(O)
print('gamma')
print(gamma)

out = open('display.profile', 'w')
out.write('%f %f %f\n'%(1.0/gamma[0], 1.0/gamma[1], 1.0/gamma[2]))
out.write('%f %f %f\n'%(O[0,0], O[0,1], O[0,2]))
out.write('%f %f %f\n'%(O[1,0], O[1,1], O[1,2]))
out.write('%f %f %f\n'%(O[2,0], O[2,1], O[2,2]))
out.close()

def get_monitors_info():
    try:
        # Execute the command hwinfo --monitor and capture the output
        output = subprocess.check_output(["hwinfo", "--monitor"]).decode("utf-8")

        # Split the output into lines
        lines = output.splitlines()

        # Initialize lists to store monitors
        vendor_lines = [line for line in lines if "Vendor:" in line]
        model_lines = [line for line in lines if "Model:" in line]

        # Extract manufacturer and model names for each monitor
        monitors = []
        for vendor_line, model_line in zip(vendor_lines, model_lines):
            vendor = vendor_line.split("Vendor:")[1].strip()
            model = model_line.split("Model:")[1].strip().strip('"')
            monitors.append({"vendor": vendor, "model": model})

        return monitors

    except Exception as e:
        print(f"Failed to retrieve monitor information: {e}")
        return []

def install_display_profile(monitor_name):
    if platform.system() != "Windows":
        # path to directory ./config/vkdt in the user directory
        config_dir = os.path.expanduser('~/.config/vkdt')

        # check if the directory exists, if not, create
        if not os.path.exists(config_dir):
            os.makedirs(config_dir)

        new_filename = os.path.join(config_dir, f"display.{monitor_name}")

        # copy the file to ./config/vkdt
        print(f"Installing display.profile as {new_filename}")
        shutil.copy('display.profile', new_filename)

    else:
        print("Windows platform detected. Display profile installation not supported on Windows.")

def main():
    # Check the session type (Wayland or X11)
    session_type = os.getenv("XDG_SESSION_TYPE")

    if session_type == "x11":
        # Installation on X11 using xrandr
        print("X11 session detected. Installing display profile using xrandr.")

        # find monitor connection name with xrandr
        proc = subprocess.Popen(['xrandr'], stdout=subprocess.PIPE)
        out, err = proc.communicate()
        lines = out.decode().split('\n')
        monitor_names = [line.split(' ')[0] for line in lines if ' connected' in line]

        if len(monitor_names) == 1:
            # If only one monitor is detected, install profile automatically
            install_display_profile(monitor_names[0])
        else:
            # ask user for which monitor the profile should be installed
            print("Available monitors:")
            for i, monitor_name in enumerate(monitor_names):
                print(f"{i+1}. {monitor_name}")

            # prompt user for selection
            selection = int(input("Enter the number of the monitor to install profile: "))
            selected_monitor_name = monitor_names[selection - 1]

            # Install profile for the selected monitor
            install_display_profile(selected_monitor_name)

    elif session_type == "wayland":
        # Installation on Wayland using hwinfo --monitor
        print("Wayland session detected. Installing display profile using hwinfo --monitor.")

        # Get monitors information
        monitors = get_monitors_info()

        if not monitors:
            print("Failed to retrieve monitor information. Cannot install display profile.")
            return

        if len(monitors) == 1:
            # If only one monitor is detected, install profile automatically
            install_display_profile(f"{monitors[0]['vendor']} {monitors[0]['model']}")
        else:
            # Print available monitors
            print("Monitors detected:")
            for i, monitor in enumerate(monitors):
                print(f"{i+1}. {monitor['vendor']} {monitor['model']}")

            # prompt user for selection
            selection = int(input("Enter the number of the monitor to install profile: "))
            selected_monitor = monitors[selection - 1]

            # Install profile for the selected monitor
            install_display_profile(f"{selected_monitor['vendor']} {selected_monitor['model']}")

    else:
        print(f"Unsupported session type: {session_type}. Cannot install display profile.")
        return

# Call the main function to start installation
if __name__ == "__main__":
    main()
